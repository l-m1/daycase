#  

class  
    - 方法与方法之间不需要加逗号分离，加了会报错  
    - Object.assign可以一次性向类添加多个方法  
    - prototype对象的contructor()属性，直接指向类的本身  
    - 类的内部所有定义的方法，都是不可枚举的  

类  
    - 必须使用new调用 否则出错  
构造函数  
    - 不同new调用也可以执行  
类的实例  
    - 使用new命令  
类的定义  
    - 使用显性定义定义其本身(即this上)，否则都是定义在原型上  
    -实例相同，原型相同，__proto__属性是相等的  
    - 使用__proto__会影响所有使用该实例的  

取值函数(getter)和存值函数(setter)  
    - 存值函数与取值函数定义在html属性的描述对象上面  
属性表达式  
Class表达式  

注意点  
    - 类和模块的内部默认就是严格模式  
    - 不存在提升  
    - name属性 返回跟在class之后的类名  
    - this的指向  
    - 静态方法(static)中包含this关键字，this指向的是类而不是实例  
        - 父类有一个静态方法，子类Bar可以调用该方法  
        - 静态对象也可从super对象上调用  

实例属性的新写法  
    - 实例属性可以定义在contructor的this上面  
    - 定义在类的最顶层  
        - 此时实例属性_counter与value()和increment()处于同一层级，不需要在实例属性加this  

静态属性  
    - ES6规定class内部只有静态方法，没有静态属性  
    - 使具有静态属性 在实例属性前加上static  
    - 老写法的静态属性定义在类的外部  
    - 新写法是显式声明 不是赋值  

私有方法和私有属性  
    - 只能在类的内部访问的方法和属性，外部不能访问  
    - 在方法前面加上_表示这是一个仅限于内部的私有方法 但是外部仍可以调用 不保险  
    - 类内部所有的方法都是对外可见的  
    - 利用symbol的唯一性 一般情况下无法获取 但使用Reflect.ownKeys()也可以  
私有属性的提案  
    - 在属性名之前加# 只能在内部使用  
    - 方法前加# 表示私有方法  
    - 私有属性也可以设置setter和getter方法  
    - 私有属性不限于从this的引用，只要在类的内部，实例也可以引用私有属性  
    - 私有属性和私有方法都只能在其类的内部调用  
new.target属性  
    - new命令引入  
    - 确定构造函数如何调用 (构造函数通过new/Reflect.consttruct()调用)  
    - 子类继承父类时，new.target会返回子类  
    - 函数外部 使用会报错  
